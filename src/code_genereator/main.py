#!/usr/bin/env python
"""
Agentic Software Factory - Flow Orchestrator

This module implements the main Flow that orchestrates the entire
software development pipeline using CrewAI Flows.

The flow progresses through these stages:
1. Initialization - Sets up the development state with requirements
2. Planning - Architect creates technical specification
3. Engineering - Database, Backend, Frontend agents implement code
4. Judging - Final validation and integration
"""

import sys
import os
import warnings
from datetime import datetime
from typing import Optional

from crewai.flow.flow import Flow, listen, start

from code_genereator.state import DevelopmentState
from code_genereator.crews import PlanningCrew, EngineeringCrew, JudgeCrew

warnings.filterwarnings("ignore", category=SyntaxWarning, module="pysbd")


def save_execution_log(state: DevelopmentState, log_dir: str = "dist/logs"):
    """
    Save the complete execution log to a markdown file.

    Args:
        state: The final DevelopmentState with all artifacts
        log_dir: Directory to save logs (default: dist/logs)
    """
    # Get project root directory
    base_dir = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
    log_path = os.path.join(base_dir, log_dir)
    os.makedirs(log_path, exist_ok=True)

    # Create timestamped filename
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    log_file = os.path.join(log_path, f"execution_log_{timestamp}.md")

    # Build the log content
    log_content = f"""# Agentic Software Factory - Execution Log

**Generated:** {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
**Flow ID:** {state.id}
**Status:** {state.status}

---

## Original Requirement

```
{state.requirement}
```

---

## PHASE 1: Planning Crew Output

### Technical Specification (Architect)

{state.plan}

---

## PHASE 2: Engineering Crew Output

###  Database Engineer Output

```sql
{state.database_code}
```

---

### Backend Engineer Output

```python
{state.backend_code}
```

---

###  Frontend Engineer Output

```tsx
{state.frontend_code}
```

---

## PHASE 3: Judge Crew Output

### Final Validation Report

{state.final_report}

---

## Summary

| Artifact | Status | Size |
|----------|--------|------|
| Plan | {'âœ…' if state.plan else 'âŒ'} | {len(state.plan)} chars |
| Database Code | {'âœ…' if state.database_code else 'âŒ'} | {len(state.database_code)} chars |
| Backend Code | {'âœ…' if state.backend_code else 'âŒ'} | {len(state.backend_code)} chars |
| Frontend Code | {'âœ…' if state.frontend_code else 'âŒ'} | {len(state.frontend_code)} chars |
| Final Report | {'âœ…' if state.final_report else 'âŒ'} | {len(state.final_report)} chars |

---

*Log generated by Agentic Software Factory v1.0*
"""

    # Write the log file
    with open(log_file, 'w', encoding='utf-8') as f:
        f.write(log_content)

    print(f"\nğŸ“ Execution log saved to: {log_file}")
    return log_file


class SoftwareDevFlow(Flow[DevelopmentState]):
    """
    Main orchestration flow for the Agentic Software Factory.
    
    This flow coordinates three specialized crews:
    - PlanningCrew: Generates technical specifications
    - EngineeringCrew: Implements database, backend, and frontend
    - JudgeCrew: Validates and integrates all components
    """
    
    initial_state = DevelopmentState
    
    @start()
    def init_development(self) -> DevelopmentState:
        """
        Initialize the development flow with the requirement.
        
        This is the entry point that sets up the initial state
        with the software requirement to be built.
        """
        print("\n" + "=" * 60)
        print("AGENTIC SOFTWARE FACTORY - STARTING")
        print("=" * 60)
        print(f"\nRequirement: {self.state.requirement[:100]}...")
        print("\n" + "-" * 60)
        
        self.state.status = "initialized"
        return self.state
    
    @listen(init_development)
    def run_planning(self) -> DevelopmentState:
        """
        Execute the Planning Crew to generate technical specification.
        
        The Architect agent analyzes the requirement and produces
        a detailed JSON-like spec for the engineering team.
        """
        print("\n" + "=" * 60)
        print("PHASE 1: PLANNING")
        print("=" * 60)
        print("Architect is designing the system specification...")
        
        planning_crew = PlanningCrew()
        result = planning_crew.crew().kickoff(
            inputs={"requirement": self.state.requirement}
        )
        
        self.state.plan = str(result.raw) if hasattr(result, 'raw') else str(result)
        self.state.status = "planned"
        
        print("\nâœ… Planning complete! Technical spec generated.")
        print("-" * 60)
        
        return self.state
    
    @listen(run_planning)
    def run_engineering(self) -> DevelopmentState:
        """
        Execute the Engineering Crew to implement the code.
        
        Three agents work sequentially:
        1. Database Engineer - Creates SQL and ORM models
        2. Backend Engineer - Creates APIs (uses DB context)
        3. Frontend Engineer - Creates UI (uses Backend context)
        """
        print("\n" + "=" * 60)
        print("PHASE 2: ENGINEERING")
        print("=" * 60)
        print("Engineering team is implementing the code...")
        
        engineering_crew = EngineeringCrew()
        result = engineering_crew.crew().kickoff(
            inputs={"plan": self.state.plan}
        )
        
        # Parse task outputs from the crew result
        # The sequential crew returns results from all tasks
        if hasattr(result, 'tasks_output') and result.tasks_output:
            tasks_output = result.tasks_output
            
            # Extract individual task outputs
            if len(tasks_output) >= 1:
                self.state.database_code = str(tasks_output[0].raw) if hasattr(tasks_output[0], 'raw') else str(tasks_output[0])
            if len(tasks_output) >= 2:
                self.state.backend_code = str(tasks_output[1].raw) if hasattr(tasks_output[1], 'raw') else str(tasks_output[1])
            if len(tasks_output) >= 3:
                self.state.frontend_code = str(tasks_output[2].raw) if hasattr(tasks_output[2], 'raw') else str(tasks_output[2])
        else:
            # Fallback: use the full output
            full_output = str(result.raw) if hasattr(result, 'raw') else str(result)
            self.state.frontend_code = full_output
        
        self.state.status = "engineered"
        
        print("\nâœ… Engineering complete! All code tiers implemented.")
        print("-" * 60)
        
        return self.state
    
    @listen(run_engineering)
    def run_validation(self) -> DevelopmentState:
        """
        Execute the Judge Crew for final validation.
        
        The Judge agent reviews all code, checks integration,
        validates naming consistency, and produces the final report.
        """
        print("\n" + "=" * 60)
        print("PHASE 3: VALIDATION")
        print("=" * 60)
        print("Judge is auditing the integration...")
        
        judge_crew = JudgeCrew()
        result = judge_crew.crew().kickoff(
            inputs={
                "requirement": self.state.requirement,
                "plan": self.state.plan,
                "database_code": self.state.database_code,
                "backend_code": self.state.backend_code,
                "frontend_code": self.state.frontend_code,
            }
        )
        
        self.state.final_report = str(result.raw) if hasattr(result, 'raw') else str(result)
        self.state.status = "completed"
        
        print("\nValidation complete! Final report generated.")
        print("=" * 60)
        print("SOFTWARE FACTORY COMPLETE!")
        print("=" * 60)
        
        return self.state


# Default example requirement
DEFAULT_REQUIREMENT = """
Build a Task Management Application with the following features:

1. User Authentication
   - User registration with email and password
   - User login/logout
   - Password reset functionality

2. Task Management
   - Create, read, update, delete tasks
   - Tasks have: title, description, due date, priority (low/medium/high), status (todo/in-progress/done)
   - Assign tasks to users
   - Filter tasks by status, priority, and due date

3. Dashboard
   - Overview of all tasks
   - Task statistics (completed, pending, overdue)
   - Recent activity feed

Tech Stack:
- Database: PostgreSQL with SQLAlchemy ORM
- Backend: FastAPI with Python
- Frontend: React with TypeScript
"""


def kickoff():
    """
    Entry point for CrewAI CLI: crewai run

    This function is called by the CrewAI CLI when running 'crewai run'.
    """
    try:
        print("\n" + "=" * 60)
        print("AGENTIC SOFTWARE FACTORY v1.0")
        print("   Powered by CrewAI Flows")
        print("=" * 60)

        flow = SoftwareDevFlow()
        result = flow.kickoff(inputs={"requirement": DEFAULT_REQUIREMENT.strip()})

        print("\n" + "=" * 60)
        print(" FINAL STATUS")
        print("=" * 60)
        print(f"Status: {result.status}")
        print(f"Project: {result.project_name or 'Generated Software'}")
        print("\n Generated Artifacts:")
        print(f"  - Plan: {'âœ…' if result.plan else 'âŒ'}")
        print(f"  - Database: {'âœ…' if result.database_code else 'âŒ'}")
        print(f"  - Backend: {'âœ…' if result.backend_code else 'âŒ'}")
        print(f"  - Frontend: {'âœ…' if result.frontend_code else 'âŒ'}")
        print(f"  - Report: {'âœ…' if result.final_report else 'âŒ'}")
        print("\n" + "=" * 60)

        # Save execution log to file
        save_execution_log(result)

        print("\n Flow completed successfully!")

    except Exception as e:
        print(f"\n Error during execution: {e}")
        sys.exit(1)


def plot():
    """
    Generate a plot/visualization of the flow.
    Called by: crewai flow plot
    """
    flow = SoftwareDevFlow()
    flow.plot()


def run(requirement: Optional[str] = None) -> DevelopmentState:
    """
    Run the Agentic Software Factory flow.
    
    Args:
        requirement: The software requirement to build.
                    If not provided, uses a default example.
    
    Returns:
        The final DevelopmentState with all generated artifacts.
    """
    if requirement is None:
        requirement = DEFAULT_REQUIREMENT
    
    # Create and run the flow
    flow = SoftwareDevFlow()
    
    # Kickoff the flow
    final_state = flow.kickoff(inputs={"requirement": requirement.strip()})
    
    return final_state


def main():
    """
    Main entry point for the Agentic Software Factory.

    Can be run with:
    - No arguments: Uses default example requirement
    - With requirement as argument: Uses provided requirement
    """
    print("\n" + "=" * 60)
    print(" AGENTIC SOFTWARE FACTORY v1.0")
    print("   Powered by CrewAI Flows")
    print("=" * 60)

    # Check for requirement in command line
    requirement = None
    if len(sys.argv) > 1:
        requirement = " ".join(sys.argv[1:])

    try:
        result = run(requirement)

        print("\n" + "=" * 60)
        print("FINAL STATUS")
        print("=" * 60)
        print(f"Status: {result.status}")
        print(f"Project: {result.project_name or 'Generated Software'}")
        print("\nGenerated Artifacts:")
        print(f"  - Plan: {'âœ…' if result.plan else 'âŒ'}")
        print(f"  - Database: {'âœ…' if result.database_code else 'âŒ'}")
        print(f"  - Backend: {'âœ…' if result.backend_code else 'âŒ'}")
        print(f"  - Frontend: {'âœ…' if result.frontend_code else 'âŒ'}")
        print(f"  - Report: {'âœ…' if result.final_report else 'âŒ'}")
        print("\n" + "=" * 60)

        # Save execution log to file
        save_execution_log(result)

        return result

    except Exception as e:
        print(f"\nError during execution: {e}")
        raise


if __name__ == "__main__":
    main()
